// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

type UserOrLimitedUser interface {
}

type ChatMessage struct {
	Attachments []string `json:"attachments,omitempty"`
	Content     string   `json:"content"`
	CreatedAt   string   `json:"createdAt"`
	Params      *string  `json:"params,omitempty"`
	Role        string   `json:"role"`
}

type Copilot struct {
	// Get the session list of actions in the workspace
	Actions []string `json:"actions"`
	// Get the session list of chats in the workspace
	Chats     []string           `json:"chats"`
	Histories []CopilotHistories `json:"histories"`
	// Get the quota of the user in the workspace
	Quota       *CopilotQuota `json:"quota"`
	WorkspaceID *string       `json:"workspaceId,omitempty"`
}

type CopilotHistories struct {
	// An mark identifying which view to use to display the session
	Action    *string       `json:"action,omitempty"`
	CreatedAt string        `json:"createdAt"`
	Messages  []ChatMessage `json:"messages"`
	SessionID string        `json:"sessionId"`
	// The number of tokens used in the session
	Tokens int `json:"tokens"`
}

type CopilotPromptMessageInput struct {
	Content string                   `json:"content"`
	Params  *string                  `json:"params,omitempty"`
	Role    CopilotPromptMessageRole `json:"role"`
}

type CopilotPromptMessageType struct {
	Content string                   `json:"content"`
	Params  *string                  `json:"params,omitempty"`
	Role    CopilotPromptMessageRole `json:"role"`
}

type CopilotPromptType struct {
	Action   *string                    `json:"action,omitempty"`
	Messages []CopilotPromptMessageType `json:"messages"`
	Model    CopilotModels              `json:"model"`
	Name     string                     `json:"name"`
}

type CopilotQuota struct {
	Limit *string `json:"limit,omitempty"`
	Used  string  `json:"used"`
}

type CreateChatMessageInput struct {
	Attachments []string         `json:"attachments,omitempty"`
	Blobs       []graphql.Upload `json:"blobs,omitempty"`
	Content     *string          `json:"content,omitempty"`
	Params      *string          `json:"params,omitempty"`
	SessionID   string           `json:"sessionId"`
}

type CreateChatSessionInput struct {
	DocID string `json:"docId"`
	// The prompt name to use for the session
	PromptName  string `json:"promptName"`
	WorkspaceID string `json:"workspaceId"`
}

type CreateCheckoutSessionInput struct {
	Coupon              *string                `json:"coupon,omitempty"`
	IdempotencyKey      string                 `json:"idempotencyKey"`
	Plan                *SubscriptionPlan      `json:"plan,omitempty"`
	Recurring           *SubscriptionRecurring `json:"recurring,omitempty"`
	SuccessCallbackLink string                 `json:"successCallbackLink"`
}

type CreateCopilotPromptInput struct {
	Action   *string                     `json:"action,omitempty"`
	Messages []CopilotPromptMessageInput `json:"messages"`
	Model    CopilotModels               `json:"model"`
	Name     string                      `json:"name"`
}

type CreateUserInput struct {
	Email    string  `json:"email"`
	Name     *string `json:"name,omitempty"`
	Password *string `json:"password,omitempty"`
}

type CredentialsRequirementType struct {
	Password *PasswordLimitsType `json:"password"`
}

type DeleteAccount struct {
	Success bool `json:"success"`
}

type DeleteSessionInput struct {
	DocID       string   `json:"docId"`
	SessionIds  []string `json:"sessionIds"`
	WorkspaceID string   `json:"workspaceId"`
}

type DocHistoryType struct {
	ID          string `json:"id"`
	Timestamp   string `json:"timestamp"`
	WorkspaceID string `json:"workspaceId"`
}

type Feed struct {
	ID          string  `json:"id"`
	Title       string  `json:"title"`
	Description string  `json:"description"`
	FeedLink    string  `json:"feedLink"`
	Image       *string `json:"image,omitempty"`
	FeedType    string  `json:"feedType"`
	Updated     string  `json:"updated"`
}

type FeedItem struct {
	FeedID              string  `json:"feedId"`
	FeedItemID          string  `json:"feedItemId"`
	Title               string  `json:"title"`
	Link                string  `json:"link"`
	DescriptionMarkdown string  `json:"descriptionMarkdown"`
	ContentMarkdown     *string `json:"contentMarkdown,omitempty"`
	CreatedAt           string  `json:"createdAt"`
}

type HumanReadableQuotaType struct {
	BlobLimit          string  `json:"blobLimit"`
	CopilotActionLimit *string `json:"copilotActionLimit,omitempty"`
	HistoryPeriod      string  `json:"historyPeriod"`
	MemberLimit        string  `json:"memberLimit"`
	Name               string  `json:"name"`
	StorageQuota       string  `json:"storageQuota"`
}

type InvitationType struct {
	// Invitee information
	Invitee *UserType `json:"invitee"`
	// User information
	User *UserType `json:"user"`
	// Workspace information
	Workspace *InvitationWorkspaceType `json:"workspace"`
}

type InvitationWorkspaceType struct {
	// Base64 encoded avatar
	Avatar string `json:"avatar"`
	ID     string `json:"id"`
	// Workspace name
	Name string `json:"name"`
}

type InviteUserType struct {
	// User accepted
	Accepted bool `json:"accepted"`
	// User avatar url
	AvatarURL *string `json:"avatarUrl,omitempty"`
	// User email verified
	CreatedAt *string `json:"createdAt,omitempty"`
	// User email
	Email *string `json:"email,omitempty"`
	// User email verified
	EmailVerified *bool `json:"emailVerified,omitempty"`
	// User password has been set
	HasPassword *bool  `json:"hasPassword,omitempty"`
	ID          string `json:"id"`
	// Invite id
	InviteID string `json:"inviteId"`
	// User name
	Name *string `json:"name,omitempty"`
	// User permission in workspace
	Permission Permission `json:"permission"`
}

type LimitedUserType struct {
	// User email
	Email string `json:"email"`
	// User password has been set
	HasPassword *bool `json:"hasPassword,omitempty"`
}

func (LimitedUserType) IsUserOrLimitedUser() {}

type ListUserInput struct {
	First *int `json:"first,omitempty"`
	Skip  *int `json:"skip,omitempty"`
}

type Mutation struct {
}

type PasswordLimitsType struct {
	MaxLength int `json:"maxLength"`
	MinLength int `json:"minLength"`
}

type PullFeedsInput struct {
	FeedID           string  `json:"feedId"`
	LatestFeedItemID *string `json:"latestFeedItemId,omitempty"`
	LatestCreatedAt  *string `json:"latestCreatedAt,omitempty"`
}

type Query struct {
}

type QueryChatHistoriesInput struct {
	Action    *bool   `json:"action,omitempty"`
	Limit     *int    `json:"limit,omitempty"`
	SessionID *string `json:"sessionId,omitempty"`
	Skip      *int    `json:"skip,omitempty"`
}

type QuotaQueryType struct {
	BlobLimit          string                  `json:"blobLimit"`
	CopilotActionLimit *string                 `json:"copilotActionLimit,omitempty"`
	HistoryPeriod      string                  `json:"historyPeriod"`
	HumanReadable      *HumanReadableQuotaType `json:"humanReadable"`
	MemberLimit        string                  `json:"memberLimit"`
	Name               string                  `json:"name"`
	StorageQuota       string                  `json:"storageQuota"`
	UsedSize           string                  `json:"usedSize"`
}

type RemoveAvatar struct {
	Success bool `json:"success"`
}

type ServerConfigType struct {
	// server base url
	BaseURL string `json:"baseUrl"`
	// credentials requirement
	CredentialsRequirement *CredentialsRequirementType `json:"credentialsRequirement"`
	// enable telemetry
	EnableTelemetry bool `json:"enableTelemetry"`
	// enabled server features
	Features []ServerFeature `json:"features"`
	// server flags
	Flags *ServerFlagsType `json:"flags"`
	// server flavor
	Flavor string `json:"flavor"`
	// server identical name could be shown as badge on user interface
	Name           string              `json:"name"`
	OauthProviders []OAuthProviderType `json:"oauthProviders"`
	// server type
	Type ServerDeploymentType `json:"type"`
	// server version
	Version string `json:"version"`
}

type ServerFlagsType struct {
	EarlyAccessControl     bool `json:"earlyAccessControl"`
	SyncClientVersionCheck bool `json:"syncClientVersionCheck"`
}

type ServerRuntimeConfigType struct {
	Description string            `json:"description"`
	ID          string            `json:"id"`
	Key         string            `json:"key"`
	Module      string            `json:"module"`
	Type        RuntimeConfigType `json:"type"`
	UpdatedAt   string            `json:"updatedAt"`
	Value       string            `json:"value"`
}

type SubscriptionPrice struct {
	Amount       *int             `json:"amount,omitempty"`
	Currency     string           `json:"currency"`
	Plan         SubscriptionPlan `json:"plan"`
	Type         string           `json:"type"`
	YearlyAmount *int             `json:"yearlyAmount,omitempty"`
}

type UpdateUserInput struct {
	// User name
	Name *string `json:"name,omitempty"`
}

type UpdateWorkspaceInput struct {
	ID string `json:"id"`
	// is Public workspace
	Public *bool `json:"public,omitempty"`
}

type UserInvoice struct {
	Amount           int                   `json:"amount"`
	CreatedAt        string                `json:"createdAt"`
	Currency         string                `json:"currency"`
	ID               string                `json:"id"`
	LastPaymentError *string               `json:"lastPaymentError,omitempty"`
	Link             *string               `json:"link,omitempty"`
	Plan             SubscriptionPlan      `json:"plan"`
	Reason           string                `json:"reason"`
	Recurring        SubscriptionRecurring `json:"recurring"`
	Status           InvoiceStatus         `json:"status"`
	UpdatedAt        string                `json:"updatedAt"`
}

type UserQuota struct {
	BlobLimit     string                  `json:"blobLimit"`
	HistoryPeriod string                  `json:"historyPeriod"`
	HumanReadable *UserQuotaHumanReadable `json:"humanReadable"`
	MemberLimit   int                     `json:"memberLimit"`
	Name          string                  `json:"name"`
	StorageQuota  string                  `json:"storageQuota"`
}

type UserQuotaHumanReadable struct {
	BlobLimit     string `json:"blobLimit"`
	HistoryPeriod string `json:"historyPeriod"`
	MemberLimit   string `json:"memberLimit"`
	Name          string `json:"name"`
	StorageQuota  string `json:"storageQuota"`
}

type UserSubscription struct {
	CanceledAt *string `json:"canceledAt,omitempty"`
	CreatedAt  string  `json:"createdAt"`
	End        string  `json:"end"`
	ID         string  `json:"id"`
	NextBillAt *string `json:"nextBillAt,omitempty"`
	// The 'Free' plan just exists to be a placeholder and for the type convenience of frontend.
	// There won't actually be a subscription with plan 'Free'
	Plan       SubscriptionPlan      `json:"plan"`
	Recurring  SubscriptionRecurring `json:"recurring"`
	Start      string                `json:"start"`
	Status     SubscriptionStatus    `json:"status"`
	TrialEnd   *string               `json:"trialEnd,omitempty"`
	TrialStart *string               `json:"trialStart,omitempty"`
	UpdatedAt  string                `json:"updatedAt"`
}

type UserType struct {
	// User avatar url
	AvatarURL *string  `json:"avatarUrl,omitempty"`
	Copilot   *Copilot `json:"copilot"`
	// User email verified
	CreatedAt *string `json:"createdAt,omitempty"`
	// User email
	Email string `json:"email"`
	// User email verified
	EmailVerified bool `json:"emailVerified"`
	// Enabled features of a user
	Features []FeatureType `json:"features"`
	// User password has been set
	HasPassword *bool  `json:"hasPassword,omitempty"`
	ID          string `json:"id"`
	// Get user invoice count
	InvoiceCount int           `json:"invoiceCount"`
	Invoices     []UserInvoice `json:"invoices"`
	// User name
	Name          string             `json:"name"`
	Quota         *UserQuota         `json:"quota,omitempty"`
	Subscription  *UserSubscription  `json:"subscription,omitempty"`
	Subscriptions []UserSubscription `json:"subscriptions"`
	Token         *TokenType         `json:"token"`
}

func (UserType) IsUserOrLimitedUser() {}

type WorkspaceBlobSizes struct {
	Size string `json:"size"`
}

type WorkspacePage struct {
	ID          string         `json:"id"`
	Mode        PublicPageMode `json:"mode"`
	Public      bool           `json:"public"`
	WorkspaceID string         `json:"workspaceId"`
}

type WorkspaceType struct {
	// Available features of workspace
	AvailableFeatures []FeatureType `json:"availableFeatures"`
	// List blobs of workspace
	Blobs []string `json:"blobs"`
	// Blobs size of workspace
	BlobsSize int `json:"blobsSize"`
	// Workspace created date
	CreatedAt string `json:"createdAt"`
	// Enabled features of workspace
	Features  []FeatureType    `json:"features"`
	Histories []DocHistoryType `json:"histories"`
	ID        string           `json:"id"`
	// member count of workspace
	MemberCount int `json:"memberCount"`
	// Members of workspace
	Members []InviteUserType `json:"members"`
	// Owner of workspace
	Owner *UserType `json:"owner"`
	// Permission of current signed in user in workspace
	Permission Permission `json:"permission"`
	// is Public workspace
	Public bool `json:"public"`
	// Get public page of a workspace by page id.
	PublicPage *WorkspacePage `json:"publicPage,omitempty"`
	// Public pages of a workspace
	PublicPages []WorkspacePage `json:"publicPages"`
	// quota of workspace
	Quota *QuotaQueryType `json:"quota"`
	// Shared pages of workspace
	SharedPages []string `json:"sharedPages"`
}

type TokenType struct {
	Refresh      string  `json:"refresh"`
	SessionToken *string `json:"sessionToken,omitempty"`
	Token        string  `json:"token"`
}

type CopilotModels string

const (
	CopilotModelsDallE3               CopilotModels = "DallE3"
	CopilotModelsGpt4Omni             CopilotModels = "Gpt4Omni"
	CopilotModelsGpt4TurboPreview     CopilotModels = "Gpt4TurboPreview"
	CopilotModelsGpt4VisionPreview    CopilotModels = "Gpt4VisionPreview"
	CopilotModelsGpt35Turbo           CopilotModels = "Gpt35Turbo"
	CopilotModelsTextEmbedding3Large  CopilotModels = "TextEmbedding3Large"
	CopilotModelsTextEmbedding3Small  CopilotModels = "TextEmbedding3Small"
	CopilotModelsTextEmbeddingAda002  CopilotModels = "TextEmbeddingAda002"
	CopilotModelsTextModerationLatest CopilotModels = "TextModerationLatest"
	CopilotModelsTextModerationStable CopilotModels = "TextModerationStable"
)

var AllCopilotModels = []CopilotModels{
	CopilotModelsDallE3,
	CopilotModelsGpt4Omni,
	CopilotModelsGpt4TurboPreview,
	CopilotModelsGpt4VisionPreview,
	CopilotModelsGpt35Turbo,
	CopilotModelsTextEmbedding3Large,
	CopilotModelsTextEmbedding3Small,
	CopilotModelsTextEmbeddingAda002,
	CopilotModelsTextModerationLatest,
	CopilotModelsTextModerationStable,
}

func (e CopilotModels) IsValid() bool {
	switch e {
	case CopilotModelsDallE3, CopilotModelsGpt4Omni, CopilotModelsGpt4TurboPreview, CopilotModelsGpt4VisionPreview, CopilotModelsGpt35Turbo, CopilotModelsTextEmbedding3Large, CopilotModelsTextEmbedding3Small, CopilotModelsTextEmbeddingAda002, CopilotModelsTextModerationLatest, CopilotModelsTextModerationStable:
		return true
	}
	return false
}

func (e CopilotModels) String() string {
	return string(e)
}

func (e *CopilotModels) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CopilotModels(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CopilotModels", str)
	}
	return nil
}

func (e CopilotModels) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CopilotPromptMessageRole string

const (
	CopilotPromptMessageRoleAssistant CopilotPromptMessageRole = "assistant"
	CopilotPromptMessageRoleSystem    CopilotPromptMessageRole = "system"
	CopilotPromptMessageRoleUser      CopilotPromptMessageRole = "user"
)

var AllCopilotPromptMessageRole = []CopilotPromptMessageRole{
	CopilotPromptMessageRoleAssistant,
	CopilotPromptMessageRoleSystem,
	CopilotPromptMessageRoleUser,
}

func (e CopilotPromptMessageRole) IsValid() bool {
	switch e {
	case CopilotPromptMessageRoleAssistant, CopilotPromptMessageRoleSystem, CopilotPromptMessageRoleUser:
		return true
	}
	return false
}

func (e CopilotPromptMessageRole) String() string {
	return string(e)
}

func (e *CopilotPromptMessageRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CopilotPromptMessageRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CopilotPromptMessageRole", str)
	}
	return nil
}

func (e CopilotPromptMessageRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EarlyAccessType string

const (
	EarlyAccessTypeAi  EarlyAccessType = "AI"
	EarlyAccessTypeApp EarlyAccessType = "App"
)

var AllEarlyAccessType = []EarlyAccessType{
	EarlyAccessTypeAi,
	EarlyAccessTypeApp,
}

func (e EarlyAccessType) IsValid() bool {
	switch e {
	case EarlyAccessTypeAi, EarlyAccessTypeApp:
		return true
	}
	return false
}

func (e EarlyAccessType) String() string {
	return string(e)
}

func (e *EarlyAccessType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EarlyAccessType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EarlyAccessType", str)
	}
	return nil
}

func (e EarlyAccessType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The type of workspace feature
type FeatureType string

const (
	FeatureTypeAIEarlyAccess      FeatureType = "AIEarlyAccess"
	FeatureTypeAdmin              FeatureType = "Admin"
	FeatureTypeCopilot            FeatureType = "Copilot"
	FeatureTypeEarlyAccess        FeatureType = "EarlyAccess"
	FeatureTypeUnlimitedCopilot   FeatureType = "UnlimitedCopilot"
	FeatureTypeUnlimitedWorkspace FeatureType = "UnlimitedWorkspace"
)

var AllFeatureType = []FeatureType{
	FeatureTypeAIEarlyAccess,
	FeatureTypeAdmin,
	FeatureTypeCopilot,
	FeatureTypeEarlyAccess,
	FeatureTypeUnlimitedCopilot,
	FeatureTypeUnlimitedWorkspace,
}

func (e FeatureType) IsValid() bool {
	switch e {
	case FeatureTypeAIEarlyAccess, FeatureTypeAdmin, FeatureTypeCopilot, FeatureTypeEarlyAccess, FeatureTypeUnlimitedCopilot, FeatureTypeUnlimitedWorkspace:
		return true
	}
	return false
}

func (e FeatureType) String() string {
	return string(e)
}

func (e *FeatureType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeatureType", str)
	}
	return nil
}

func (e FeatureType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InvoiceStatus string

const (
	InvoiceStatusDraft         InvoiceStatus = "Draft"
	InvoiceStatusOpen          InvoiceStatus = "Open"
	InvoiceStatusPaid          InvoiceStatus = "Paid"
	InvoiceStatusUncollectible InvoiceStatus = "Uncollectible"
	InvoiceStatusVoid          InvoiceStatus = "Void"
)

var AllInvoiceStatus = []InvoiceStatus{
	InvoiceStatusDraft,
	InvoiceStatusOpen,
	InvoiceStatusPaid,
	InvoiceStatusUncollectible,
	InvoiceStatusVoid,
}

func (e InvoiceStatus) IsValid() bool {
	switch e {
	case InvoiceStatusDraft, InvoiceStatusOpen, InvoiceStatusPaid, InvoiceStatusUncollectible, InvoiceStatusVoid:
		return true
	}
	return false
}

func (e InvoiceStatus) String() string {
	return string(e)
}

func (e *InvoiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InvoiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InvoiceStatus", str)
	}
	return nil
}

func (e InvoiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OAuthProviderType string

const (
	OAuthProviderTypeGitHub OAuthProviderType = "GitHub"
	OAuthProviderTypeGoogle OAuthProviderType = "Google"
	OAuthProviderTypeOidc   OAuthProviderType = "OIDC"
)

var AllOAuthProviderType = []OAuthProviderType{
	OAuthProviderTypeGitHub,
	OAuthProviderTypeGoogle,
	OAuthProviderTypeOidc,
}

func (e OAuthProviderType) IsValid() bool {
	switch e {
	case OAuthProviderTypeGitHub, OAuthProviderTypeGoogle, OAuthProviderTypeOidc:
		return true
	}
	return false
}

func (e OAuthProviderType) String() string {
	return string(e)
}

func (e *OAuthProviderType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OAuthProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OAuthProviderType", str)
	}
	return nil
}

func (e OAuthProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User permission in workspace
type Permission string

const (
	PermissionAdmin Permission = "Admin"
	PermissionOwner Permission = "Owner"
	PermissionRead  Permission = "Read"
	PermissionWrite Permission = "Write"
)

var AllPermission = []Permission{
	PermissionAdmin,
	PermissionOwner,
	PermissionRead,
	PermissionWrite,
}

func (e Permission) IsValid() bool {
	switch e {
	case PermissionAdmin, PermissionOwner, PermissionRead, PermissionWrite:
		return true
	}
	return false
}

func (e Permission) String() string {
	return string(e)
}

func (e *Permission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Permission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Permission", str)
	}
	return nil
}

func (e Permission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The mode which the public page default in
type PublicPageMode string

const (
	PublicPageModeEdgeless PublicPageMode = "Edgeless"
	PublicPageModePage     PublicPageMode = "Page"
)

var AllPublicPageMode = []PublicPageMode{
	PublicPageModeEdgeless,
	PublicPageModePage,
}

func (e PublicPageMode) IsValid() bool {
	switch e {
	case PublicPageModeEdgeless, PublicPageModePage:
		return true
	}
	return false
}

func (e PublicPageMode) String() string {
	return string(e)
}

func (e *PublicPageMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PublicPageMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PublicPageMode", str)
	}
	return nil
}

func (e PublicPageMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RuntimeConfigType string

const (
	RuntimeConfigTypeArray   RuntimeConfigType = "Array"
	RuntimeConfigTypeBoolean RuntimeConfigType = "Boolean"
	RuntimeConfigTypeNumber  RuntimeConfigType = "Number"
	RuntimeConfigTypeObject  RuntimeConfigType = "Object"
	RuntimeConfigTypeString  RuntimeConfigType = "String"
)

var AllRuntimeConfigType = []RuntimeConfigType{
	RuntimeConfigTypeArray,
	RuntimeConfigTypeBoolean,
	RuntimeConfigTypeNumber,
	RuntimeConfigTypeObject,
	RuntimeConfigTypeString,
}

func (e RuntimeConfigType) IsValid() bool {
	switch e {
	case RuntimeConfigTypeArray, RuntimeConfigTypeBoolean, RuntimeConfigTypeNumber, RuntimeConfigTypeObject, RuntimeConfigTypeString:
		return true
	}
	return false
}

func (e RuntimeConfigType) String() string {
	return string(e)
}

func (e *RuntimeConfigType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeConfigType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeConfigType", str)
	}
	return nil
}

func (e RuntimeConfigType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServerDeploymentType string

const (
	ServerDeploymentTypeAffine     ServerDeploymentType = "Affine"
	ServerDeploymentTypeSelfhosted ServerDeploymentType = "Selfhosted"
)

var AllServerDeploymentType = []ServerDeploymentType{
	ServerDeploymentTypeAffine,
	ServerDeploymentTypeSelfhosted,
}

func (e ServerDeploymentType) IsValid() bool {
	switch e {
	case ServerDeploymentTypeAffine, ServerDeploymentTypeSelfhosted:
		return true
	}
	return false
}

func (e ServerDeploymentType) String() string {
	return string(e)
}

func (e *ServerDeploymentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerDeploymentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerDeploymentType", str)
	}
	return nil
}

func (e ServerDeploymentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServerFeature string

const (
	ServerFeatureCopilot ServerFeature = "Copilot"
	ServerFeatureOAuth   ServerFeature = "OAuth"
	ServerFeaturePayment ServerFeature = "Payment"
)

var AllServerFeature = []ServerFeature{
	ServerFeatureCopilot,
	ServerFeatureOAuth,
	ServerFeaturePayment,
}

func (e ServerFeature) IsValid() bool {
	switch e {
	case ServerFeatureCopilot, ServerFeatureOAuth, ServerFeaturePayment:
		return true
	}
	return false
}

func (e ServerFeature) String() string {
	return string(e)
}

func (e *ServerFeature) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServerFeature(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServerFeature", str)
	}
	return nil
}

func (e ServerFeature) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionPlan string

const (
	SubscriptionPlanAi         SubscriptionPlan = "AI"
	SubscriptionPlanEnterprise SubscriptionPlan = "Enterprise"
	SubscriptionPlanFree       SubscriptionPlan = "Free"
	SubscriptionPlanPro        SubscriptionPlan = "Pro"
	SubscriptionPlanSelfHosted SubscriptionPlan = "SelfHosted"
	SubscriptionPlanTeam       SubscriptionPlan = "Team"
)

var AllSubscriptionPlan = []SubscriptionPlan{
	SubscriptionPlanAi,
	SubscriptionPlanEnterprise,
	SubscriptionPlanFree,
	SubscriptionPlanPro,
	SubscriptionPlanSelfHosted,
	SubscriptionPlanTeam,
}

func (e SubscriptionPlan) IsValid() bool {
	switch e {
	case SubscriptionPlanAi, SubscriptionPlanEnterprise, SubscriptionPlanFree, SubscriptionPlanPro, SubscriptionPlanSelfHosted, SubscriptionPlanTeam:
		return true
	}
	return false
}

func (e SubscriptionPlan) String() string {
	return string(e)
}

func (e *SubscriptionPlan) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPlan(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionPlan", str)
	}
	return nil
}

func (e SubscriptionPlan) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionRecurring string

const (
	SubscriptionRecurringMonthly SubscriptionRecurring = "Monthly"
	SubscriptionRecurringYearly  SubscriptionRecurring = "Yearly"
)

var AllSubscriptionRecurring = []SubscriptionRecurring{
	SubscriptionRecurringMonthly,
	SubscriptionRecurringYearly,
}

func (e SubscriptionRecurring) IsValid() bool {
	switch e {
	case SubscriptionRecurringMonthly, SubscriptionRecurringYearly:
		return true
	}
	return false
}

func (e SubscriptionRecurring) String() string {
	return string(e)
}

func (e *SubscriptionRecurring) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionRecurring(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionRecurring", str)
	}
	return nil
}

func (e SubscriptionRecurring) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive            SubscriptionStatus = "Active"
	SubscriptionStatusCanceled          SubscriptionStatus = "Canceled"
	SubscriptionStatusIncomplete        SubscriptionStatus = "Incomplete"
	SubscriptionStatusIncompleteExpired SubscriptionStatus = "IncompleteExpired"
	SubscriptionStatusPastDue           SubscriptionStatus = "PastDue"
	SubscriptionStatusPaused            SubscriptionStatus = "Paused"
	SubscriptionStatusTrialing          SubscriptionStatus = "Trialing"
	SubscriptionStatusUnpaid            SubscriptionStatus = "Unpaid"
)

var AllSubscriptionStatus = []SubscriptionStatus{
	SubscriptionStatusActive,
	SubscriptionStatusCanceled,
	SubscriptionStatusIncomplete,
	SubscriptionStatusIncompleteExpired,
	SubscriptionStatusPastDue,
	SubscriptionStatusPaused,
	SubscriptionStatusTrialing,
	SubscriptionStatusUnpaid,
}

func (e SubscriptionStatus) IsValid() bool {
	switch e {
	case SubscriptionStatusActive, SubscriptionStatusCanceled, SubscriptionStatusIncomplete, SubscriptionStatusIncompleteExpired, SubscriptionStatusPastDue, SubscriptionStatusPaused, SubscriptionStatusTrialing, SubscriptionStatusUnpaid:
		return true
	}
	return false
}

func (e SubscriptionStatus) String() string {
	return string(e)
}

func (e *SubscriptionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriptionStatus", str)
	}
	return nil
}

func (e SubscriptionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
